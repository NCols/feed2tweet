#!/usr/bin/env python
# vim:ts=4:sw=4:ft=python:fileencoding=utf-8
# Copyright Â© 2015 Carl Chenet <carl.chenet@ohmytux.com>
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

"""Checks an RSS feed and posts new entries to twitter."""

from ConfigParser import SafeConfigParser
from argparse import ArgumentParser
import cPickle
import codecs
import logging
import os
import sys

import feedparser
import tweepy


__version__ = '0.1'

config = None


def post_update(status):
    global config
    consumer_key = config.get('twitter', 'consumer_key')
    consumer_secret = config.get('twitter', 'consumer_secret')
    access_token = config.get('twitter', 'access_token')
    access_token_secret = config.get('twitter', 'access_token_secret')
    auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
    auth.set_access_token(access_token, access_token_secret)
    api = tweepy.API(auth)
    try:
        api.update_status(status)
    except tweepy.error.TweepError, e:
        logging.warning("Error occurred while updating status: %s", e)
    else:
        return True


def main():
    """The main function."""
    global config
    parser = ArgumentParser(description=__doc__)
    parser.add_argument('--version', action='version', version=__version__)
    parser.add_argument('-c', '--config',
                        default=os.getenv('XDG_CONFIG_HOME',
                                          '~/.config/feed2tweet.ini'),
                        help='Location of config file (default: %(default)s)',
                        metavar='FILE')
    parser.add_argument('-a', '--all', action='store_true', default=False,
                        dest='all',
                        help='tweet all RSS items, regardless of cache')
    parser.add_argument('-l', '--limit', dest='limit', default=10,
                        help='tweet only LIMIT items (default: %(default)s)')
    parser.add_argument('-n', '--dry-run', dest='dryrun',
                        action='store_true', default=False,
                        help='Do not actually post tweets')
    parser.add_argument('--hashtaglist', dest='hashtaglist'
                        help='a list of hashtag to match')
    options = parser.parse_args()
    config = SafeConfigParser()
    if not config.read(os.path.expanduser(options.config)):
        sys.exit('Could not read config file')
    cachefile = os.path.expanduser(os.getenv('XDG_CACHE_HOME',
                                             config.get('cache', 'cachefile')))
    rss_uri = config.get('rss', 'uri')
    feed = feedparser.parse(rss_uri)

    # lots of scary warnings about possible security risk using this method
    # but for local use I'd rather do this than a try-catch with open()
    if not os.path.isfile(cachefile):
        # make a blank cache file
        cPickle.dump({'id': None}, open(cachefile, 'wb'), -1)

    cache = cPickle.load(open(cachefile))
    if options.hashtaglist:
        severalwordshashtags = codecs.open(options.hashtaglist,
                                           encoding='utf-8').readlines()
        severalwordshashtags = [i.rstrip('\n') for i in severalwordshashtags]
        entries = feed['entries'][0:options.limit]

    cached = False
    for entry in entries:
        if not options.all and entry['id'] == cache['id']:
            break

        rss = {
            'id': entry['id'],
            'link': entry['link'],
            'title': entry['title'],
            'summary': entry['summary'],
        }
        severalwordsinhashtag = False
        if options.hashtaglist:
            prehashtags = entry['tags'][0]['term']
            tmphashtags = entry['tags'][0]['term']
            for element in severalwordshashtags:
                if element in prehashtags:
                    severalwordsinhashtag = True
                    tmphashtags = prehashtags.replace(element,
                                                      ''.join(element.split()))
        if severalwordsinhashtag:
            tmphashtags = tmphashtags.replace("'", "")
            finalhashtags = tmphashtags.split(' ')
            # issue with splitting hashtags in 2 words is right there
            rss['hashtag'] = ' '.join(['#%s' % i for i in finalhashtags])
        else:
            rss['hashtag'] = ' '.join(['#%s' % i for i in entry['tags'][0]['term'].split()[:2]])
        if options.dryrun:
            logging.warning('would post %s %s %s',
                            rss['title'], rss['link'], rss['hashtag'])
        else:
            post_update('%s %s %s'
                        % (rss['title'], rss['link'], rss['hashtag']))

            # We keep the first feed in the cache, to use feed2tweet
            # in normal mode the next time
            if not cached:
                cPickle.dump(rss, open(cachefile, 'wb'), -1)
                cached = True


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG, format='%(message)s')
    try:
        main()
    except KeyboardInterrupt as e:
        # Ctrl-c
        sys.exit('aborted')
    except Exception:
        logging.exception('unexpected exception')
        raise
